<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>Symmetric Encryption in ESAPI 2.0</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 3.0  (Linux)">
	<META NAME="CREATED" CONTENT="20100214;0">
	<META NAME="CHANGED" CONTENT="20100214;22400700">
	<META NAME="CHANGEDBY" CONTENT="Kevin W. Wall">
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<H1 ALIGN=CENTER>Symmetric Encryption in ESAPI 2.0</H1>
<H2>ESAPI.properties Properties Relevant to Symmetric Encryption</H2>
<P>Those properties that are new since ESAPI 2.0-rc2 are shown in
<FONT COLOR="#ff0000">red</FONT>. Values shown in <FONT COLOR="#0000ff">blue</FONT>
are ones that you would replace.</P>
<TABLE WIDTH=703 BORDER=1 BORDERCOLOR="#000000" CELLPADDING=4 CELLSPACING=0 STYLE="page-break-before: auto; page-break-after: auto; page-break-inside: auto">
	<COL WIDTH=249>
	<COL WIDTH=202>
	<COL WIDTH=226>
	<TR VALIGN=TOP>
		<TH WIDTH=249>
			<P>Property Name</P>
		</TH>
		<TH WIDTH=202>
			<P>Default Value</P>
		</TH>
		<TH WIDTH=226>
			<P>Comment</P>
		</TH>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=249>
			<PRE><FONT SIZE=2>ESAPI.Encryptor</FONT></PRE>
		</TD>
		<TD WIDTH=202>
			<PRE><FONT SIZE=2>org.owasp.esapi.reference.crypto.JavaEncryptor</FONT></PRE>
		</TD>
		<TD WIDTH=226>
			<P><FONT SIZE=2>The class implementing the Encryptor interface and
			returned by ESAPI.encryptor().</FONT></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=249>
			<PRE><FONT SIZE=2>Encryptor.MasterKey</FONT></PRE>
		</TD>
		<TD WIDTH=202>
			<P><FONT SIZE=2><FONT COLOR="#0000ff">&lt;initially unset&gt;</FONT></FONT></P>
		</TD>
		<TD WIDTH=226>
			<P><FONT SIZE=2>The base64-encoded SecretKey. The key must be
			appropriate to the specified key size and cipher algorithm.</FONT></P>
			<P><FONT SIZE=2>Set as per the instructions in the ESAPI
			Installation Guide.</FONT></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=249>
			<PRE><FONT SIZE=2>Encryptor.MasterSalt</FONT></PRE>
		</TD>
		<TD WIDTH=202>
			<P><FONT SIZE=2><FONT COLOR="#0000ff">&lt;initially unset&gt;</FONT></FONT></P>
		</TD>
		<TD WIDTH=226>
			<P><FONT SIZE=2>A base64-encoded random “salt”. This should be
			at least 20-bytes. It is used to generate a random (but
			consistent) public/private key pair used in asymmetric encryption
			and digital signatures.</FONT></P>
			<P><FONT SIZE=2>Set as per the instructions in the ESAPI
			Installation Guide.</FONT></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=249>
			<PRE><STRIKE><FONT SIZE=2>Encryptor.EncryptionAlgorithm</FONT></STRIKE></PRE>
		</TD>
		<TD WIDTH=202>
			<P><FONT SIZE=2><PRE>AES</PRE></FONT></P>
		</TD>
		<TD WIDTH=226>
			<P><FONT SIZE=2>A deprecated property, superseded by
			Encryptor.CipherTransformation.</FONT></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=249>
			<P STYLE="margin-bottom: 0in"><FONT SIZE=2><FONT COLOR="#ff0000">
            <PRE>Encryptor.CipherTransformation</PRE></FONT></FONT></P>
		</TD>
		<TD WIDTH=202>
			<P><FONT SIZE=2><FONT
            COLOR="#ff0000"><PRE>AES/CBC/PKCS5Padding</PRE></FONT></FONT></P>
		</TD>
		<TD WIDTH=226>
			<P><FONT SIZE=2>Specifies the cipher transformation  to use for
			symmetric encryption. The format is
			cipherAlgorithm/cipherMode/paddingScheme.</FONT></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=249>
			<P STYLE="margin-bottom: 0in"><FONT FACE="DejaVu Sans Mono,
            sans-serif"><FONT SIZE=2><FONT
            COLOR="#ff0000"><PRE>Encryptor.EncryptionKeyLength</PRE></FONT></FONT></FONT></P>
		</TD>
		<TD WIDTH=202 SDVAL="128" SDNUM="1033;">
			<P><FONT SIZE=2><FONT COLOR="#ff0000"><PRE>128</PRE></FONT></FONT></P>
		</TD>
		<TD WIDTH=226>
			<P><FONT SIZE=2>Key size, in bits. Required for cipher algorithms
			that support multiple key sizes.</FONT></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=249>
			<PRE><FONT SIZE=2><FONT COLOR="#ff0000">Encryptor.ChooseIVMethod</FONT></FONT></PRE>
		</TD>
		<TD WIDTH=202>
			<PRE><FONT SIZE=2><FONT COLOR="#ff0000">random</FONT></FONT></PRE>
		</TD>
		<TD WIDTH=226>
			<P><FONT SIZE=2>Legal values are “random” or “fixed”.
			Random is recommended. Set to “fixed” if required for
			compatibility with legacy or third party software. If set to
			“fixed”, then the property Encryptor.fixedIV must also be
			fixed.</FONT></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=249>
			<PRE><FONT SIZE=2><FONT COLOR="#ff0000">Encryptor.fixedIV</FONT></FONT></PRE>
		</TD>
		<TD WIDTH=202>
			<P><FONT COLOR="#0000ff"><FONT
            SIZE=2><PRE>0x000102030405060708090a0b0c0d0e0f</PRE></FONT></FONT></P>
		</TD>
		<TD WIDTH=226>
			<P><FONT SIZE=2>A hex-encoded value to use as a fixed IV. Only
			used if the property Encryptor.fixedIV is set to “fixed”.</FONT></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=249>
			<PRE><FONT SIZE=2><FONT COLOR="#ff0000">Encryptor.CipherText.useMAC</FONT></FONT></PRE>
		</TD>
		<TD WIDTH=202>
			<PRE><FONT SIZE=2><FONT COLOR="#ff0000">true</FONT></FONT></PRE>
		</TD>
		<TD WIDTH=226>
			<P><FONT SIZE=2>Whether or not CipherText should use a message
			authentication code (MAC) with it.  This prevents an adversary
			from altering the IV as well as allowing a more fool-proof way of
			determining the decryption failed because of an incorrect key
			being supplied. This refers to the &quot;separate&quot; MAC
			calculated and stored in CipherText, not part of any MAC that is
			calculated as a result of a &quot;combined mode&quot; cipher mode.</FONT></P>
			<P><FONT SIZE=2>Note: If the cipher mode used is one specified in
			the comma-separated list of cipher modes given in the property
			Encryptor.cipher_modes.combined_modes, then a separate MAC is not
			calculated for CipherText regardless of the setting of this
			property.</FONT></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=249>
			<PRE><FONT SIZE=2><FONT COLOR="#ff0000">Encryptor.PreferredJCEProvider</FONT></FONT></PRE>
		</TD>
		<TD WIDTH=202>
			<PRE><FONT SIZE=2><FONT COLOR="#ff0000">SunJCE</FONT></FONT></PRE>
		</TD>
		<TD WIDTH=226>
			<P><FONT SIZE=2>Specifies the preferred JCE provider. The
			Encryptor reference implementation, JavaEncryptor, attempts to
			load this JCE provider at position 0 (i.e., the first position)
			when the JavaEncryptor class is first loaded. The value may either
			be the provider name (e.g., “BC” for Bouncy Castle) or the
			fully qualified class name implementing java.security.Provider for
			the desired JCE provider.</FONT></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=249>
			<PRE><FONT SIZE=2><FONT COLOR="#ff0000">Encryptor.cipher_modes.additional_allowed</FONT></FONT></PRE>
		</TD>
		<TD WIDTH=202>
			<PRE><FONT SIZE=2 COLOR="#ff0000"><PRE>CBC</PRE></FONT></PRE>
		</TD>
		<TD WIDTH=226>
			<P><FONT SIZE=2>Additional cipher modes allowed for ESAPI 2.0
			symmetric encryption. These cipher modes are in <I>addition</I> to
			those specified by the property
			'Encryptor.cipher_modes.combined_modes'.</FONT></P>
			<P><FONT SIZE=2>Note: We will add support for streaming modes like
			CFB &amp; OFB once we add support for 'specified' to the property
			'Encryptor.ChooseIVMethod' (probably in ESAPI 2.1).</FONT></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=249>
			<PRE><FONT SIZE=2><FONT COLOR="#ff0000">Encryptor.cipher_modes.combined_modes</FONT></FONT></PRE>
		</TD>
		<TD WIDTH=202>
			<PRE><FONT SIZE=2 COLOR="#ff0000"><PRE>GCM,CCM,IAPM,EAX,OCB,CWC</PRE></FONT></PRE>
		</TD>
		<TD WIDTH=226>
			<P><FONT SIZE=2>Comma-separated list of cipher modes that provide
			*BOTH* confidentiality *AND* message authenticity. (NIST refers to
			such cipher modes as &quot;combined modes&quot; so that's what we
			shall call them.) If any of these cipher modes are used then no
			MAC is calculated and stored in the CipherText upon encryption.
			Likewise, if one of these cipher modes is used with decryption, no
			attempt will be made to validate the MAC contained in the
			CipherText object regardless of whether it contains one or not.
			Since the expectation is that these cipher modes support support
			message authenticity already, injecting a MAC in the CipherText
			object would be at best redundant.  </FONT>
			</P>
			<P><FONT SIZE=2>Note that as of JDK 1.5, the SunJCE provider does
			not support <I>any</I> of these cipher modes. Of these listed,
			only GCM and CCM are currently NIST approved.</FONT></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=249>
			<PRE><FONT SIZE=2><FONT COLOR="#ff0000">Encryptor.PlainText.overwrite</FONT></FONT></PRE>
		</TD>
		<TD WIDTH=202 SDVAL="1" SDNUM="1033;0;BOOLEAN">
			<PRE><FONT SIZE=2><FONT COLOR="#ff0000">true</FONT></FONT></PRE>
		</TD>
		<TD WIDTH=226>
			<P><FONT SIZE=2>Whether or not the plaintext bytes for the
			PlainText object may be overwritten with “*” characters and
			then marked eligible for garbage collection. If not set, this is
			still treated as 'true'. If this is set to 'true', you will not
			be able to use any PlainText object after you have used it with
			one of the Encryptor encrypt() methods.</FONT></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=249>
			<PRE><FONT COLOR="#000000"><FONT SIZE=2>Encryptor.CharacterEncoding</FONT></FONT></PRE>
		</TD>
		<TD WIDTH=202>
			<PRE><FONT COLOR="#000000"><FONT SIZE=2>UTF-8</FONT></FONT></PRE>
		</TD>
		<TD WIDTH=226>
			<P><FONT SIZE=2>The default encoding used for certain aspects such
			as signing and sealing.</FONT></P>
		</TD>
	</TR>
</TABLE>
<H2>How the Old (Deprecated) Methods Were Used</H2>
<P>To encrypt / decrypt using the String-based, deprecated methods
carried over from ESAPI 1.4, code similar to the following would be
used. 
</P>
<PRE>    String myplaintext = &quot;My plaintext&quot;;
    try {
        String ciphertext = ESAPI.encryptor().encrypt(myplaintext);
        String decrypted  = ESAPI.encryptor().decrypt(ciphertext);
        assert decrypted.equals(myplaintext);
    } catch(EncryptionException ex) {
        // Log error then return error designation however appropriate
    }</PRE><P>
This code will still work, however if you are using the standard
(default) reference for <CODE>ESAPI.Encryptor</CODE>, which is
<CODE>org.owasp.esapi.reference.crypto.JavaEncryptor</CODE>, the
cipher transformation used with be that specified by the property
<CODE>Encryptor.CipherTransformation</CODE> with a key size (when the
algorithm supports a variable key size) of that specified by
<CODE>Encryptor.EncryptionKeyLength</CODE> and the IV type specified
by <CODE>Encryptor.ChooseIVMethod</CODE>. What is not provided by
these methods (and why they are deprecated) is that they provide no
mechanism to ensure message authenticity unless they are used with a
so-called “combined” cipher mode such as CCM or GCM.<SPAN STYLE="font-style: normal">
(Note that as of JDK 1.6, the default JCE provider, “SunJCE”,
does not support any combined cipher modes.)</SPAN></P>
<H2>Encrypting / Decrypting with the New Methods -- The Simple Usage</H2>
<P>Using the new encryption / decryption methods is somewhat more
complicated, but this is in part because they are more flexible and
that flexibility means that more information needs to be communicated
as to the details of the encryption. 
</P>
<P>A code snippet using the new methods that use the master
encryption key would look something like this: 
</P>
<PRE>    String myplaintext = &quot;My plaintext&quot;;
    try {
        CipherText ciphertext =
            ESAPI.encryptor().encrypt( new PlainText(myplaintext) );
        PlainText recoveredPlaintext = ESAPI.encryptor().decrypt(ciphertext) );
        assert myplaintext.equals( recoveredPlaintext.toString() );
    } catch(EncryptionException ex) {
        // Log error then return error designation however appropriate.
    }</PRE><P>
Yes, this is a bit more complicated, but it will 1) work across
different hardware platforms and operating systems whereas the older
methods may not, and 2) it provides for <I>authenticity</I> <I><B>and</B></I>
<I>confidentiality</I> of the ciphertext regardless of which cipher
mode is chosen.</P>
<P>Also, these new methods allow a general byte array to be
encrypted, not just a Java String. If one needed to encrypt a byte
array with the old deprecated method, one would first have to use 
</P>
<PRE>    byte[] plaintextByteArray = { /* byte array to be encrypted */ };
    String plaintext = new String(plaintextByteArray, &quot;UTF-8&quot;);</PRE><P>
all the while catching the required <CODE>UnsupportedEncodingException</CODE>.
For example, to handle this in ESAPI 1.4, one would have to write
something like:</P>
<PRE>    try {
        byte[] plaintextByteArray = { /* byte array to be encrypted */ };
        String myplaintext = new String(plaintextByteArray, &quot;UTF-8&quot;);
        String ciphertext = ESAPI.encryptor().encrypt(myplaintext);
        String decrypted  = ESAPI.encryptor().decrypt(ciphertext);
        byte[] recoveredBytes = decrypted.getBytes(“UFT-8”);
        assert java.util.Arrays.equals( plaintextByteArray, recoveredBytes );
    } catch( <CODE>UnsupportedEncodingException</CODE> ex) {
        // Should not happen but need to catch and deal with it anyhow.
        // Log error then return error designation however appropriate.
    } catch(EncryptionException ex) {
        // Log error then return error designation however appropriate.
    }</PRE><P>
However, dealing with this in ESAPI 2.0 is not any more cumbersome
than dealing with Strings:</P>
<PRE>    try {
        byte[] plaintextByteArray = { /* byte array to be encrypted */ };
        CipherText ciphertext =
            ESAPI.encryptor().encrypt( new PlainText(plaintextByteArray) );
        PlainText recoveredPlaintext = ESAPI.encryptor().decrypt(ciphertext) );

        assert java.util.Arrays.equals( plaintextByteArray,
                                        recoveredPlaintext.asBytes() );
    } catch(EncryptionException ex) {
        // Log error then return error designation however appropriate.
    }</PRE><P>
Ideally when you are encrypting sensitive data you do not want the
plaintext sensitive data to be left lying around after it is
encrypted. Instead, you should overwrite them after their value as
been used. However, when you are using immutable Strings, this is not
possible using native Java methods. But if you are able to pass in
byte arrays that are passed directly to <CODE>PlainText</CODE>
objects (as shown above), the <I>default</I> is to overwrite this
after they are encrypted. <!-- Need to verify this. It was like this, but think I may have changed it to return copy rather than reference based on FindBugs report. --><SPAN STYLE="background: #ffff00">If
the default for </SPAN><CODE><SPAN STYLE="background: #ffff00">Encryptor.PlainText.overwrite</SPAN></CODE><SPAN STYLE="background: #ffff00">
of </SPAN><CODE><B><SPAN STYLE="background: #ffff00">true</SPAN></B></CODE><SPAN STYLE="background: #ffff00">
had been used, then the array </SPAN><CODE><SPAN STYLE="background: #ffff00">plaintextByteArray</SPAN></CODE><SPAN STYLE="background: #ffff00">
would have been overwritten with ASCII “*” characters.</SPAN></P>
<H2><SPAN STYLE="background: transparent">Encrypting / Decrypting
with the New Methods – Storing Encrypted Data</SPAN></H2>
<P><SPAN STYLE="background: transparent">If you use one of the new
Encryptor encrypt() / decrypt() methods, how do you persist the
CipherText object returned by the encrypt() methods and how do you
restore it to pass to the decrypt() method?</SPAN></P>
<P><SPAN STYLE="background: transparent">The following example code
snippet will illustrate this. In the following example we will simply
write out the serialized CipherText object to a local file, but
obviously you could hex- or base64-encode the serialized byte array
and store it in a database or sent it in a SOAP XML message to a web
service, etc.</SPAN></P>
<P>
  <PRE>
    public class PersistedEncryptedData
    {
        public static int persistEncryptedData(PlainText plaintext,
                                                String filename)
            throws EncryptionException, IOException
        {
            File serializedFile = new File(filename);
            serializedFile.delete(); // Delete any old serialized file.

            CipherText ct = ESAPI.encryptor().encrypt(plaintext);
            byte[] serializedCiphertext = ct.asPortableSerializedByteArray();

            FileOutputStream fos = new FileOutputStream(serializedFile);
            fos.write(serializedCiphertext);
            fos.close();
            return serializedCiphertext.length;
        }

        public static PlainText restorePlaintext(String encryptedDataFilename)
            throws EncryptionException, IOException
        {
            File serializedFile = new File(encryptedDataFilename);
            FileInputStream fis = new FileInputStream(serializedFile);
            int avail = fis.available();
            byte[] bytes = new byte[avail];
            fis.read(bytes, 0, avail);

            CipherText restoredCipherText =
                                CipherText.fromPortableSerializedBytes(bytes);
            fis.close();
            PlainText plaintext = ESAPI.encryptor().decrypt(restoredCipherText);
            return plaintext;
        }
    }
  </PRE>
<H2>Encrypting / Decrypting with the New Methods -- Advanced Usage</H2>
<P>ESAPI 1.4 and earlier only allowed you to use the master key
(<FONT FACE="DejaVu Sans Mono, sans-serif">MasterPassword</FONT> in
ESAPI 1.4;  <CODE>Encryptor.MasterKey</CODE> in ESAPI 2.0) to encrypt
and decrypt with. But encryption with a single key seldom is
sufficient. For instance, lets say that your application has a need
to encrypt both bank account numbers and credit card numbers. The
encrypted bank account numbers are to be sent to one recipient and
the encrypted credit card numbers are to be sent to a different
recipient. Obviously in such cases, you do not want to share the same
key for both recipients. 
</P>
<P>In ESAPI 1.4 there was not much you can do, but in ESAPI 2.0 and
later, there are new encryption / decryption methods that allow you
to specify a specific <CODE>SecretKey</CODE>. There is also a static
helper method in <CODE>CryptoHelper</CODE> to allow you to generate a
<CODE>SecretKey</CODE> of a specific type. (Distribution of this key
is out of scope for this particular example, but for the moment, we
will assume that secret keys are first generated, and then
distributed to the recipients out-of-band. On you could distribute
them dynamically via asymmetric encryption assuming that you've
previously exchanged public keys with the recipients.)</P>
<P>The following illustrates how these new methods might be used. 
</P>
<P>First, we would generate some appropriate secret keys and
distribute them securely (e.g., perhaps over SSL/TLS) or exchange
them earlier out-of-band to the intended recipients. (E.g., one could
put them on two separate thumb drives and use a trusted courier to
distribute them to the recipients or one could use PGP-mail or S/MIME
to securely email them, etc.) 
</P>
<PRE>    // Generate two random, 128-bit AES keys to be distributed out-of-band.
    import javax.crypto.SecretKey;
    import org.owasp.esapi.crypto.CryptoHelper;
    import org.owasp.esapi.codecs.Hex;

    public class MySecretKeys {
        public void main(String[] args) {
          try {
            SecretKey bankAcctKey = CryptoHelper.generateSecretKey(&quot;AES&quot;, 128);
            SecretKey credCardKey = CryptoHelper.generateSecretKey(&quot;AES&quot;, 128);

            System.out.println(&quot;Bank account key: &quot; +
                Hex.encode( bankAcctKey.getEncoding(), true ) );
            System.out.println(&quot;Credit card key: &quot; +
                Hex.encode( credCardKey.getEncoding(), true ) );
          } catch(Exception ex) {
            ex.printStackTrace(System.err);
            System.exit(1);
          }
          System.exit(0);
        }
    }</PRE><P>
Second, these keys would be printed out and stored somewhere secure
by our application, perhaps using something like ESAPI's
<CODE>EncryptedProperties</CODE> class, where they could later be
retrieved and used. 
</P>
<P>In the following code, we assume that the <CODE>SecretKey</CODE>
values have already been initialized elsewhere. 
</P>
<PRE>    SecretKey bankAcctKey = ...;        // These might be read from EncryptedProperties
    SecretKey credCardKey = ...;        // or from a restricted database, etc.
    ...
    String bankAccountNumber = ...;     // Assume obtained elsewhere
    String creditCardNumber = ...;      // Ditto
    ...
    try {
        // Encrypt each with their appropriate secret key
        CipherText encryptedBankAcct =
            ESAPI.encryptor().encrypt( bankAcctKey, new PlainText(bankAccountNumber) );
        CipherText encryptedCreditCard =
            ESAPI.encryptor().encrypt( credCardKey, new PlainText(creditCardNumber) );
        ...
        // Decrypt using appropriate secret key
        PlainText recoveredBankAcct = ESAPI.encryptor().decrypt( bankAcctKey, encryptedBankAcct ) );
        assert bankAccountNumber.equals( recoveredBankAcct );
        ... etc. ...
    } catch(EncryptionException ex) {
        // Log error then return error designation however appropriate.
    }</PRE>
</BODY>
</HTML>
