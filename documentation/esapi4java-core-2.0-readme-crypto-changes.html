<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE>Encryption in OWASP ESAPI Java 2.0</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 3.0  (Linux)">
	<META NAME="CREATED" CONTENT="0;0">
	<META NAME="CHANGEDBY" CONTENT="Kevin Wall-OpenSuSE">
	<META NAME="CHANGED" CONTENT="20091004;16112100">
	<META NAME="Info 1" CONTENT="">
	<META NAME="Info 2" CONTENT="">
	<META NAME="Info 3" CONTENT="">
	<META NAME="Info 4" CONTENT="">
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<H1 ALIGN=CENTER>Why Is OWASP Changing ESAPI Encryption?</H1>
<H2>Reasons for Change</H2>
<P STYLE="margin-bottom: 0in">The existing ESAPI 1.4 uses the cipher
mode Electronic Code Book (ECB) for encryption with <CODE>Encryptor</CODE>
and the reference implementation, <CODE>JavaEncryptor</CODE>.
ECB cipher mode is the simplest cipher mode to use, but it is also
cryptographically very weak. If more than one block of plaintext is
encrypted with the same key, those identical blocks of ciphertext
always encrypt to the same ciphertext block, thus revealing patterns
in the plaintext input. For example, these images from Wikipedia's
<A HREF="http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation">Block
cipher modes of operation</A> illustrate this point well: 
</P>
<TABLE BORDER=0 CELLPADDING=4 CELLSPACING=0>
	<TR>
		<TD>
			<P ALIGN=CENTER><FONT COLOR="#0000FF"><A HREF="http://en.wikipedia.org/wiki/File:Tux.jpg"><FONT COLOR="#0000FF"><IMG SRC="http://upload.wikimedia.org/wikipedia/commons/5/56/Tux.jpg" NAME="graphics1" ALT="Original Tux image" ALIGN=BOTTOM WIDTH=196 HEIGHT=216 BORDER=1></FONT></A></FONT></P>
		</TD>
		<TD>
			<P ALIGN=CENTER><FONT COLOR="#0000FF"><A HREF="http://en.wikipedia.org/wiki/File:Tux_ecb.jpg"><FONT COLOR="#0000FF"><IMG SRC="http://upload.wikimedia.org/wikipedia/commons/f/f0/Tux_ecb.jpg" NAME="graphics2" ALT="Tux image encrypted using ECB mode" ALIGN=BOTTOM WIDTH=196 HEIGHT=216 BORDER=1></FONT></A></FONT></P>
		</TD>
		<TD>
			<P ALIGN=CENTER><FONT COLOR="#0000FF"><A HREF="http://en.wikipedia.org/wiki/File:Tux_secure.jpg"><FONT COLOR="#0000FF"><IMG SRC="http://upload.wikimedia.org/wikipedia/commons/a/a0/Tux_secure.jpg" NAME="graphics3" ALT="Tux image encrypted with other modessuch as CBC" ALIGN=BOTTOM WIDTH=196 HEIGHT=216 BORDER=1></FONT></A></FONT></P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=CENTER><I>Original Tux image</I></P>
		</TD>
		<TD>
			<P ALIGN=CENTER><I>Image encrypted using ECB mode</I></P>
		</TD>
		<TD>
			<P ALIGN=CENTER><I>Image encrypted using modes other than ECB</I></P>
		</TD>
	</TR>
</TABLE>
<P>Ciphertext encrypted with ECB cipher mode are also subject to
&quot;block replay attacks&quot;. See Bruce Schneier's <A HREF="http://www.google.com/url?sa=t&amp;source=web&amp;ct=res&amp;cd=2&amp;url=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DA6ZO2D6ayNwC%26pg%3DPT216%26lpg%3DPT216%26dq%3Decb%2B%2522block%2Breplay%2522%26source%3Dbl%26ots%3DiEbAWQpu0e%26sig%3D8xiUva4XKaAOfPJEPsULPAJPk88%26hl%3Den%26ei%3Da6yISoLQPJOuMI-Z_OkE%26sa%3DX%26oi%3Dbook_result%26ct%3Dresult%26resnum%3D2&amp;ei=a6yISoLQPJOuMI-Z_OkE&amp;rct=j&amp;q=ecb+%22block+replay%22&amp;usg=AFQjCNF-IjrE4dL7M2LELh48hYPP6A_bpQ"><I>Applied
Cryptography: protocols, algorithms, and source code</I> </A>for
details. 
</P>
<P>Also, because ESAPI 1.4 only supports ECB cipher mode with no
padding, it cannot be used to decrypt data encrypted with anything
other than an algorithm using ECB cipher mode and no padding. Most
encryption (outside of ESAPI) uses some other cipher mode (e.g.,
Cipher Block Chaining (CBC) mode) and some sort of padding scheme,
such as PKCS#5 padding. 
</P>
<H2>The Encryption Changes in ESAPI Java 2.0</H2>
<P>Briefly speaking, the changes being implemented for ESAPI Java 2.0
are: 
</P>
<OL>
	<LI><P STYLE="margin-bottom: 0in">The <I>default</I> cipher
	transformation is changing from &quot;AES-256/ECB/None&quot; (i.e.,
	256-bit AES in ECB cipher mode and no padding) used in ESAPI Java
	1.4 to &quot;AES-128/CBC/PKCS5Padding&quot; (i.e., 128-bit AES in
	CBC cipher mode and PKCS#5 padding) in ESAPI Java 2.0. 128-bit AES
	is also slightly faster than 256-bit AES, and it does not require
	you downloading the unlimited jurisdiction strength policy files
	from Sun Microsystems. For those believing that 128-bit AES is not
	sufficiently strong--bruting forcing it (except perhaps with a
	reasonable quantum computer) is still not feasible--and certain key
	related attacks (see Biryukov, Dunkelman, Keller, Khovratovich, and
	Shamir's <A HREF="http://eprint.iacr.org/2009/374">Cryptology ePrint
	Archive: Report 2009/374 -- Key Recovery Attacks of Practical
	Complexity on AES Variants With Up To 10 Rounds </A>for further
	details) show that longer key sizes in AES may not always be the
	best.</P>
	<LI><P STYLE="margin-bottom: 0in">Because most other cipher modes
	other than ECB and CTR require an Initialization Vector (IV), a
	mechanism to handle both fixed and random IVs has been added. 
	</P>
	<LI><P STYLE="margin-bottom: 0in">A mechanism to attempt to preserve
	backward compatibility with ESAPI Java 1.4 (via
	<CODE>org.owasp.esapi.reference.crypto.LegacyJavaEncryptor</CODE>)
	has been added, but because of the security implications of using
	the ECB cipher mode, you are encouraged to stop using this as soon
	as possible. (In fact, this backward compatibility mechanism should
	be considered deprecated and likely will be dropped in some future
	ESAPI Java release.) 
	</P>
	<LI><P>The byte-encoding has been changed from native byte encoding
	for wherever the JVM happens to be running to UTF-8 byte-encoding
	throughout. (Note: Backward compatibility mode does <I>NOT</I>
	account for this difference.) This was needed so that one could
	(say) encrypt on a Sparc running Solaris and then move the encrypted
	data to an Intel host running Windows and still be able to decrypt
	the data. Without this change, this could not be guaranteed.</P>
</OL>
<H2>The Good, the Bad, and the Ugly</H2>
<P>Or put another way, there are always trade-offs to be made... 
</P>
<H3>The Good</H3>
<P>We get improved security by encouraging the use of stronger cipher
modes (and ESAPI is all about &quot;enterprise security&quot;,
right?). 
</P>
<P>Frankly if I were a PCI or SOX auditor and I found a company that
was encrypting credit card, bank account, or social security numbers
using ECB mode, I'd rap someone across the knuckles. But I'll let it
go this time. :-) 
</P>
<H3>The Bad</H3>
<P>With cipher modes that require an IV, the same IV must be used
both to encrypt and decrypt. While it is not required that the IV be
kept secret from adversaries, there are some attacks that are
possible if the adversary is permitted to alter the IV at will and
observe the results. 
</P>
<P>So that leaves two choices for the IV: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0in">Using a <I><B>fixed IV</B></I>:
	The IV can be agreed upon out-of-band by the parties exchanging
	encrypted messages. In this way, the encrypted data that is stored
	and/or transmitted can be limited to only the <I>raw</I> ciphertext.
		</P>
	<LI><P>Using a <I><B>random IV</B></I>: Most cryptographers prefer
	to use a random IV, typically a different one with each message to
	be encrypted. However, doing so on encrypted data that will be
	persisted (e.g., to a database) or transmitted to the recipient this
	random IV must be stored / made known. Therefore, the raw ciphertext
	can no longer suffice; whatever random IV that was chosen must be
	communicated. 
	</P>
</UL>
<P>Likewise, the use of padding is going to add some overhead to the
length of the ciphertext. 
</P>
<P STYLE="margin-bottom: 0in">For example, a short plaintext of 0-15 bytes,
this overhead can be around 200% of the total plaintext size. This
overhead diminishes (as a percent of the total plaintext size) as the
plaintext size increases. Here is a table that illustrates this: 
</P>
<TABLE WIDTH=348 BORDER=1 CELLPADDING=4 CELLSPACING=0>
	<COL WIDTH=126>
	<COL WIDTH=204>
	<TR>
		<TD WIDTH=126>
			<P ALIGN=CENTER>Original input length <BR>(# bytes) 
			</P>
		</TD>
		<TD WIDTH=204>
			<P ALIGN=CENTER>Base64-encoded length of <BR>ciphertext (with IV
			and padding) encrypted with 128-bit AES in CBC mode</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=126>
			<P ALIGN=LEFT>0-15</P>
		</TD>
		<TD WIDTH=204>
			<P ALIGN=LEFT>44</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=126>
			<P ALIGN=LEFT>16-31</P>
		</TD>
		<TD WIDTH=204>
			<P ALIGN=LEFT>64</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=126>
			<P ALIGN=LEFT>32-47</P>
		</TD>
		<TD WIDTH=204>
			<P ALIGN=LEFT>88</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=126>
			<P ALIGN=LEFT>48-63</P>
		</TD>
		<TD WIDTH=204>
			<P ALIGN=LEFT>108</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=126>
			<P ALIGN=LEFT>64-79</P>
		</TD>
		<TD WIDTH=204>
			<P ALIGN=LEFT>128</P>
		</TD>
	</TR>
	<TR>
		<TD WIDTH=126>
			<P ALIGN=LEFT>Etc. Each additional 16 bytes of plaintext...</P>
		</TD>
		<TD WIDTH=204>
			<P ALIGN=LEFT>...adds 20 additional bytes</P>
		</TD>
	</TR>
</TABLE>
<P>As you can see, since the size of the IV and the amount of padding
bytes are fixed at a maximum, this overhead goes down as the length
of the plaintext message increases. The IV is always a fixed length
for a given cipher; it is always the same as the cipher block size.
The padding can vary, but for PKCS5 padding, the padding will be
between 1 to the cipher block size (in bits) / 8 bytes. For AES,
the cipher block size is 128-bits, but more typically, a cipher's
block size is 64-bits so the padding would be between 1 to 16 bytes for
AES and 1 to 8 bytes for a 64-bit block size cipher and the IV would be
IV would be 16 bytes for AES and 8 bytes for most other ciphers.
(Note: If space were truly a concern, say because of legacy database
tables, etc., then one could set the properties
<PRE>
	Encryptor.ChooseIVMethod=fixed
	Encryptor.fixedIV=&lt;your_hex_encoded_IV_here&gt;
</PRE>
in <code>ESAPI.properties</code> and then
store only the raw ciphertext bytes, but this is not quite as
secure as using a random IV for each plaintext that is encrypted.)
<H3>The Ugly</H3>
<P>Well, so far, this &quot;bad&quot; news may be bad for you but
good for your database and/or storage vendor, but you probably can
live with it, especially if you are willing to do a little bit of
recoding. 
</P>
<P>But wait Skippy, don't go running off just quite yet. As Robert
Heinlein wrote in his 1966 novel <I>The Moon is a Harsh Mistress</I>
&quot;There ain't no such thing as a free lunch&quot;. (Some of us
more hardened cynics know it more commonly as <I>TANSTAAFL</I>.) 
</P>
<P>All this backward compatibility and flexibility comes at the
additional cost of complexity, and not <I>merely</I> additional
complexity in the reference implementation. There is also some
additional complexity in the ESAPI <CODE>Encryptor</CODE>
interfaces as well. 
</P>
<P>In particular, there is a new <CODE>CipherText</CODE>
class to coalesce all this complexity of handling the ciphertext
result from encryption operations as well as a reference
implementation (<CODE>DefaultCipherText</CODE>)
for it as well. And then there is one new encryption and one new
decryption method for the <CODE>Encryptor</CODE>
interface. Specifically, the encrypt and decrypt methods have been
generalized as: 
</P>
<PRE STYLE="margin-left: 0.49in; margin-bottom: 0.2in"><FONT
COLOR="#000000"><FONT FACE="Monospace">CipherText encrypt(SecretKey key, PlainText plaintext) throws EncryptionException;</FONT></FONT></PRE><P>
and 
</P>
<PRE STYLE="margin-left: 0.49in; margin-bottom: 0.2in"><FONT
COLOR="#000000"><FONT FACE="Monospace">PlainText decrypt(SecretKey key, CipherText ciphertext) throws EncryptionException</FONT></FONT></PRE><P>
The two existing interfaces from ESAPI 1.4 and earlier</P>
<PRE STYLE="margin-left: 0.49in; margin-bottom: 0.2in">String encrypt(String plaintext) throws EncryptionException</PRE><P>
and 
</P>
<PRE STYLE="margin-left: 0.49in; margin-bottom: 0.2in">String decrypt(String ciphertext) throws EncryptionException</PRE><P>
are still supported but have been deprecated, mainly because they do
not support integrity / authenticity checks which most cryptographers
consider essential. Also these older String-based encrypt() /
decrypt() interfaces have slightly different semantics than do their
ESAPI 1.4 counterparts in that these methods default to CBC cipher
mode, PKCS5Padding, and a random IV whereas the older ESAPI 1.4
methods only support relatively weak ECB cipher modes. However, this
difference in cipher mode means that if you have data that was
previously encrypted using ESAPI 1.4 or earlier, you will not be able
to decrypt it using the ESAPI 2.0</P>
<PRE STYLE="margin-left: 0.49in; margin-bottom: 0.2in">String decrypt(String ciphertext) throws EncryptionException</PRE><P>
method. If you require such compatibility, you should set
<CODE>org.owasp.esapi.reference.crypto.LegacyJavaEncryptor</CODE>
for the property <CODE>ESAPI.Encryptor</CODE> in
your <B>ESAPI.properties</B> file, this class likely will be removed
in a future ESAPI release. (This class is intended only to provide
backward compatibility so that you may decrypt previously encrypted
data and the class itself is deprecated to indicate this.)</P>
<P>Note that while the new String-based encrypt() / decrypt() methods
use the stronger CBC cipher mode with a random IV, they still do not
ensure authenticity and integrity so the more general encrypt() /
decrypt() methods should be preferred over the String-based ones.
(See below for examples of how to use these new methods.)</P>
<P>Further details are provided in the <CODE>Encryptor</CODE>
Javadoc.</P>
<H2>Symmetric Encryption in ESAPI 2.0</H2>
<H3>ESAPI.properties Properties Relevant to Symmetric Encryption</H3>
<P>Those properties that are new are shown in <FONT COLOR="#ff0000">red</FONT>.
Values shown in <FONT COLOR="#0000FF">blue</FONT> are ones that you
would replace.</P>
<PRE>
    #
    # Default values are shown.
    #
        # Set this to            org.owasp.esapi.reference.crypto.LegacyJavaEncryptor
        # for compatibility with ESAPI 1.4. See next section for details.
    ESAPI.Encryptor=org.owasp.esapi.reference.crypto.JavaEncryptor

    Encryptor.MasterKey=<FONT COLOR="#0000ff">pJhlri8JbuFYDgkqtHmm9s0Ziug2PE7ovZDyEPm4j14=</FONT>
    Encryptor.MasterSalt=<FONT COLOR="#0000ff">SbftnvmEWD5ZHHP+pX3fqugNysc=</FONT>

        # This property only used by LegacyJavaEncryptor...
    Encryptor.EncryptionAlgorithm=AES

    <FONT COLOR="#ff0000">Encryptor.CipherTransformation=AES/CBC/PKCS5Padding</FONT>
    <FONT COLOR="#ff0000">Encryptor.EncryptionKeyLength=128</FONT>
    <FONT COLOR="#ff0000">Encryptor.ChooseIVMethod=random</FONT>

        # This is only used when  Encryptor.ChooseIVMethod=fixed     is set, otherwise a random IV is used.
        # Should only be used for compatibility with legacy systems when space
        # to store the encrypted values is at a premium or your partner in
        # encryption requires you to use a specific IV. In such cases, you
        # should set it to whatever fixed IV is required using hexadecimal representation.
        # Note however use of a random IV is always preferable.
    <FONT COLOR="#ff0000">Encryptor.fixedIV=</FONT><FONT COLOR="#0000FF">0xdbd1a3636024b7b402da7d6fe3fb056e</FONT>
    <FONT COLOR="#ff0000">Encryptor.CipherText.useMAC=true</FONT>
</PRE>
<H3>
How the Old (Deprecated) Methods Were Used</H3>
<P>To encrypt / decrypt using the String-based, deprecated methods
carried over from ESAPI 1.4, code similar to the following would be
used.
</P>
<PRE>
    String myplaintext = &quot;My plaintext&quot;;
    try {
        String ciphertext = ESAPI.encryptor().encrypt(myplaintext);
        String decrypted  = ESAPI.encryptor().decrypt(ciphertext);
        assert decrypted.equals(myplaintext);
    } catch(EncryptionException ex) {
        // Log error then return error designation however appropriate
    }
</PRE>
<P>
This code will still work, however if you are using the standard
(default) reference for <CODE>ESAPI.Encryptor</CODE>,
which is <CODE>org.owasp.esapi.reference.crypto.JavaEncryptor</CODE>,
the cipher transformation used with be that specified by the property
<CODE>Encryptor.CipherTransformation</CODE> with
a key size (when the algorithm supports a variable key size) of that
specified by <CODE>Encryptor.EncryptionKeyLength</CODE>
and the IV type specified by <CODE>Encryptor.ChooseIVMethod</CODE>.
This is opposed to the old ESAPI 1.4 default of 256-bit AES in ECB
mode with no padding (and obviously no IV). If you have no need to
decrypt data that was previously encrypted using ESAPI 1.4, this
should cause no troubles. However, if you need to use these old
String-based encrypt / decrypt methods to deal with data encrypted
using ESAPI 1.4 you will need to configure your ESAPI.properties file
to use the so-called legacy encryption. This is done by setting:</P>
<PRE STYLE="margin-left: 0.49in; margin-bottom: 0.2in">ESAPI.Encryptor=org.owasp.esapi.reference.crypto.LegacyJavaEncryptor</PRE><P>
which will cause these two String-based encrypt / decrypt methods to
use 256-bit AES with cipher transformation “AES/ECB/None”. Note
that the new encryption / decryption methods continue to work as they
do as if you were using the <CODE>JavaEncryptor</CODE>
class. Note that the legacy encryption can <I>only </I><SPAN STYLE="font-style: normal">use
the master encryption key, but that is all that is required for
compatibility with ESAPI 1.4.</SPAN></P>
<H3>Encrypting / Decrypting with the New Methods -- The Simple Usage</H3>
<P>Using the new encryption / decryption methods is somewhat more
complicated, but this is in part because they are more flexible and
that flexibility means that more information needs to be communicated
as to the details of the encryption. 
</P>
<P>A code snippet using the new methods that use the master
encryption key would look something like this: 
</P>
<PRE>
    String myplaintext = &quot;My plaintext&quot;;
    try {
        CipherText ciphertext =
            ESAPI.encryptor().encrypt( new PlainText(myplaintext) );
        PlainText recoveredPlaintext = ESAPI.encryptor().decrypt(ciphertext) );
        assert myplaintext.equals( recoveredPlaintext.toString() );
    } catch(EncryptionException ex) {
        // Log error then return error designation however appropriate.
    }
</PRE>
<P>
Yes, this is a bit more complicated, but it will 1) work across
different hardware platforms and operating systems whereas the older
methods may not, and 2) it provides for authenticity and integrity of
the ciphertext.</P>
<P>Also, these new methods allow a general byte array to be
encrypted, not just a Java String. If one needed to encrypt a byte
array with the old methods one would first have to use 
</P>
<PRE>    byte[] plaintextByteArray = { /* byte array to be encrypted */ };
    String plaintext = new String(plaintextByteArray, &quot;UTF-8&quot;);</PRE><P>
all the while catching the required <CODE>UnsupportedEncodingException</CODE>.
For example, to handle this in ESAPI 1.4, one would have to write:</P>
<PRE>    try {
        byte[] plaintextByteArray = { /* byte array to be encrypted */ };
        String myplaintext = new String(plaintextByteArray, &quot;UTF-8&quot;);
        String ciphertext = ESAPI.encryptor().encrypt(myplaintext);
        String decrypted  = ESAPI.encryptor().decrypt(ciphertext);
        byte[] recoveredBytes = decrypted.getBytes(“UFT-8”);
        assert java.util.Arrays.equals( plaintextByteArray, recoveredBytes );
    } catch( <CODE>UnsupportedEncodingException</CODE> ex) {
        // Should not happen but need to catch and deal with it anyhow.
        // Log error then return error designation however appropriate.
    } catch(EncryptionException ex) {
        // Log error then return error designation however appropriate.
    }</PRE><P>
However, dealing with this in ESAPI 2.0 is not any more cumbersome
than dealing with Strings:</P>
<PRE>    try {
        byte[] plaintextByteArray = { /* byte array to be encrypted */ };
        CipherText ciphertext =
            ESAPI.encryptor().encrypt( new PlainText(plaintextByteArray) );
        PlainText recoveredPlaintext = ESAPI.encryptor().decrypt(ciphertext) );

        // Assumes that Encryptor.PlainText.overwrite=false ...
        assert java.util.Arrays.equals( plaintextByteArray, recoveredPlaintext.asBytes() );
    } catch(EncryptionException ex) {
        // Log error then return error designation however appropriate.</PRE><P>
}</P>
<P>Ideally when you are encrypting sensitive data you do not want the
plaintext sensitive data to be left lying around after it is
encrypted. Instead, you should overwrite them after their value as
been used. However, when you are using immutable Strings, this is not
possible using native Java methods. But if you are able to pass in
byte arrays that are passed directly to <CODE>PlainText</CODE>
objects (as shown above), the <I>default</I> is to overwrite this
after they are encrypted. If the default for
<CODE>Encryptor.PlainText.overwrite</CODE> of
<CODE><B>true</B></CODE> had been used, then the
array <CODE>plaintextByteArray</CODE> would have
been overwritten with ASCII “*” characters.</P>
<H3>Encrypting / Decrypting with the New Methods -- Advanced Usage</H3>
<P>
ESAPI 1.4 and earlier only allowed you to use the master key
<code>Encryptor.MasterKey</code> to encrypt and decrypt with.
But encryption with a single key is not always sufficient. For
instance, lets say that your application has a need to encrypt both
bank account numbers and credit card numbers. The encrypted bank account
numbers are to be sent to one recipient and the encrypted credit card numbers
are to be sent to a different recipient. Obviously in such cases, you do not
want to share the same key for both recipients.
</P>
<P>
In ESAPI 1.4 there was not much you can do, but in ESAPI 2.0 and
later, there are new encryption / decryption methods that allow you
to specify a specific <code>SecretKey</code>. There is also a static
helper method in <code>CryptoHelper</code> to allow you to generate a
<code>SecretKey</code> of a specific type. (Distribution of this key
is out of scope for this particular example, but for the moment, we will
assume that secret keys are first generated, and then distributed to the
recipients out-of-band.)
</P>
<P>
The following illustrates how these new methods might be used.
</P><P>
First, we would generate some appropriate secret keys and distribute
them securely and most likely out-of-band to the intended recipients.
(E.g., one could put them on two separate thumb drives and use
a trusted courier to distribute them to the recipients or one
could use PGP-mail or S/MIME to securely email them, etc.)
<PRE>
    // Generate two random, 128-bit AES keys to be distributed out-of-band.
    import javax.crypto.SecretKey;
    import org.owasp.esapi.crypto.CryptoHelper;
    import org.owasp.esapi.codecs.Hex;

    public class MySecretKeys {
        public void main(String[] args) {
          try {
            SecretKey bankAcctKey = CryptoHelper.generateSecretKey("AES", 128);
            SecretKey credCardKey = CryptoHelper.generateSecretKey("AES", 128);

            System.out.println("Bank account key: " +
                Hex.encode( bankAcctKey.getEncoding(), true ) );
            System.out.println("Credit card key: " +
                Hex.encode( credCardKey.getEncoding(), true ) );
          } catch(Exception ex) {
            ex.printStackTrace(System.err);
            System.exit(1);
          }
          System.exit(0);
        }
    }
</PRE>
Second, these keys would be printed out and stored somewhere secure
by our application, perhaps using something like ESAPI's
<code>EncryptedProperties</code> class, where they could later be
retrieved and used.
<P>
In the following code, we assume that the <code>SecretKey</code> values
have already been initialized elsewhere.
<PRE>
    SecretKey bankAcctKey = ...;        // These might be read from EncryptedProperties
    SecretKey credCardKey = ...;        // or from a restricted DB, etc.
    ...
    String bankAccountNumber = ...;     // Assume obtained elsewhere
    String creditCardNumber = ...;      // Ditto
    ...
    try {
        // Encrypt each with their appropriate secret key
        CipherText encryptedBankAcct =
            ESAPI.encryptor().encrypt( bankAcctKey, new PlainText(bankAccountNumber) );
        CipherText encryptedCreditCard =
            ESAPI.encryptor().encrypt( credCardKey, new PlainText(creditCardNumber) );
        ...
        // Decrypt using appropriate secret key
        PlainText recoveredBankAcct = ESAPI.encryptor().decrypt( bankAcctKey, encryptedBankAcct ) );
        assert bankAccountNumber.equals( recoveredBankAcct );
        ... etc. ...
    } catch(EncryptionException ex) {
        // Log error then return error designation however appropriate.
    }
</PRE>
</BODY>
</HTML>
